# An End-to-End Encryption File Sharing System

<h1><b> Overview </h1></b>
In this project, I utilized <i>cryptographic primitives</i> - such as a public key encryption, hash function, HMAC, HKDF, PBKDF, digital signatures, symmetric encrypion, and random byte generators - to <b>design and implement </b> a client application for a secure file sharing system. 

Imagine something similar to Dropbox, but secured with end-to-end encryption. This means that no adversery nor eavesdropper can view or tamper with the client's data. This includes the server, malicious actors, Internet providers, telecom providers, or any other third party member. Only communicating users can access the cryptographic keys needed to converse and are the only people who can decrypt and access shared files.

In this client application, I implemented the following actions that users could take:
1. Logging in with a username and password without loss of security (such as hackers logging in using rainbow-table attacks).
2. Loading and saving files to the servers without loss of confidentiality (where the files have IND-CPA security).
3. Appending and overwriting saved files on the server without loss of confidentiality (where the files also have IND-CPA security).
4. Sharing saved files with other users (using an authentication system) while ensuring confidentiality and integrity amongst users and files.
5. Revoking access to users who previously shared files with them, while also ensuring that the revoked user cannot use the client API to find, access, or manipulate the file revoked to them.

<h1><b> Threat Model </h1></b>

Shannon’s Maxim and Kerckhoffs’ principle is implemented in this client API: assume that all adversaries know the design of the client application and have access to the source code.

<h2><b> Keystore (trusted) </h2></b>
The <b>Keystore</b> is a <b>trusted</b> service hosted on a server and network to which users can publish their public keys. It will honestly execute the Keystore API. No adversary will be able to maliciously overwrite, modify, or otherwise tamper with any key-value entry stored on the Keystore server. Since Keystore can only store public keys and its API is publicly available, all actors can look up any entry in the Keystore. This means that the adversary can read the contents of the public keystore and take advantage of automation and brute-forcing, constrained by practical limits.

<h2><b> Datastore (untrusted) </h2></b>

The <b>Datastore</b> is an <b>untrusted</b> service hosted on a server and network that provides persistent storage and <b>is controlled by an adversary</b>. Since Datastore can be malicious, any sensitive data stored into it must be protected with confidentiality and integrity beforehand. The Datastore is structured as a key-value store. In this context, key refers to an unique identifier (UUID) that is used to index the value (in []btyte form) in the database, and does not refer to a crypographic key. All key-value entries in Datastore exist in a single, global namespace and Datastore does not perform any access control. Therefore, <i> any value entry can be overwritten or deleted by any user who knows the corresponding storage key</i>.

The adversary can view, record, modify, and/or add any key-value pair stored in the Datastore API, and can view and record the content and metadata of all requests (set/get/delete) to the Datastore API. This allows the adversary to know which users users store each key-value pair and the order in which key-value pairs are stored, viewed, or deleted. 

<h2><b> Malicious Users </h2></b>

Users who were granted access to a file (via <i>ShareFile()</i>), but have since had their access revoked, may become malicious. These users may attempt to use the Datastore API to perform operations on files using all the relevant information they have previously recorded about the file (including any cryptographic material and any <i>access_token(s)</i> generated by the <i>ShareFile</i> method). All datastore writes made by a user in an attempt to modify or re-acquire file privileges are malicious actions. 
Also note that due to Shannon’s Maxim and Kerckhoffs’ principle, the adversary knows the design and implementation of the client API and has access to the source code.

<h1><b> Design Model </h1></b>


