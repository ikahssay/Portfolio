<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS184 Cloth Sim</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<style>
    body {
        font-family: 'Montserrat', sans-serif;
        display: flex;
        width: 100%;
        height: 100%;
        justify-content: center;
        line-height: 150%;
        background-image: url("Img/Background.png");
        background-repeat: repeat;
        margin: 0 auto;
    }
    
    figure {
        width: 100%;
        margin: 0 auto;
        margin-bottom: 100px;
    }
    
    img {
        max-width: 80%;
        min-width: 150px;
    }
    
    p {}
    
    .wrapper {
        width: 80%;
        max-width: 700px;
        padding: 75px 100px 50px 100px;
        background-color: white;
    }
    
    .img-grid {
        width: 100%;
        margin-top: 100px;
        display: flex;
        justify-content: space-between;
        /* flex-wrap: wrap; */
    }
    
    figcaption {
        font-size: small;
    }
    
    .code {
        font-family: 'Source Code Pro', monospace;
    }
</style>

<body>
    <div class="wrapper">
        <h1>CS184 Project 4: Cloth Simulation</h1>
        <h4>By Lucy Lou and Iman Kahssay</h4>
        <br></br>
        <h2>Overview</h2>
        <p>In this project, we implemented data structures and physics functions to simulate a cloth’s movement. In the first part, we built our grid of masses and springs that represent the cloth. In part 2, we integrated forces (such as gravity) into our
            implementation, so the cloth would accurately fall and hang from pinned points. In part 3, we dealt with the cloth making collisions with other objects and planes, and in part 4, we handled self-collisions. In the last part, we wrote shader
            programs to render different surfaces with lighting and textures.</p>
        <br></br>
        <h2>Part 1: Masses and Springs</h2>
        <p>Our cloth is modeled by a grid of evenly spaced point masses connected by springs. Each point mass contains attributes for its current position, last position forces, and whether it is “pinned” or not. The pinned value is for part 2, where we
            “hang” the cloth from pinned points. Spring objects contain a rest length, the 2 point masses it connects to, and a spring type. We store our created point masses and springs in vectors to be used in the rest of the project. We implemented
            3 different types of springs: structural, shearing, and bending.
        </p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part_1_structural_constraints.png" alt="Part 1 Only Structural Springs">
                <figcaption>Only Structural Springs</figcaption>
            </figure>
        </div>
        <div class="img-grid">
            <figure>
                <img src="Img/Part_1_shearing_constraints.png" alt="Part 1 Only Shearing Springs">
                <figcaption>Only Shearing Springs</figcaption>
            </figure>
        </div>
        <div class="img-grid">
            <figure>
                <img src="Img/Part_1_bending_constraints.png" alt="Part 1 Only Bending Springs">
                <figcaption>Only Bending Springs</figcaption>
            </figure>
        </div>
        <div class="img-grid">
            <figure>
                <img src="Img/Part_1_structural_shearing_and_bending_constraints .png" alt="Part 1 All 3 Spring Types">
                <figcaption>All 3 Spring Types</figcaption>
            </figure>
        </div>
        <h2>Part 2: Simulation via Numerical Integration</h2>
        <p> To make our cloth look and behave more realistically, we implemented physical equations of motion onto the cloth from one time step to the next. We did this by calculating forces for each point mass using external and spring accelerations. Then we used Verlet integration to calculate the position the point mass would move to based on its force. Lastly, we made
            sure that the springs don't get too deformed in the process by fixing springs whose point masses were stretched more than 10% of their rest length.
        </p>
        <p>After implementing everything we explained above, we were able to render a cloth pinned at specifiic positions (at the top of the cloth), and falling realistically (due to gravity and other forces). We can adjust settings such as the spring constant ks, density of the point masses, and damping (simulates friction).
        </p>
        <p>Here are some examples of a cloth pinned at 2 points with different spring constants, ks = 500N/m, 5000N/m, and 50000N/m. As the spring constant decreases, the cloth is less ‘bouncy” and sags more. As fs increases, the cloth retains its shape
            better, as if the fabric is less stretchy.</p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part2_Ks500Cloth2.png" alt="Part 2 ks: 500N/m">
                <figcaption>ks: 500N/m</figcaption>
            </figure>
            <figure>
                <img src="Img/Part2_DefaultCloth2.png" alt="Part 2 ks: 5000N/m (default)">
                <figcaption>ks: 5000N/m (default)</figcaption>
            </figure>
            <figure>
                <img src="Img/Part2_Ks50000Cloth2.png" alt="Part 2 ks: 50000N/m">
                <figcaption>ks: 50000N/m</figcaption>
            </figure>
        </div>
        <p> Here we change the density of the cloth, where it's densities are 1g/cm^2, 15g/cm^2, and 30g/cm^2 respectively. The smaller the density, the less the cloth sags - which makes sense as low density would mean the cloth is “lighter.” When density is adjusted to be larger,
            the cloth sags, since it is heavier.</p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part2_Density1Cloth2.png" alt="Part 2 Density: 1g/cm^2">
                <figcaption>Density: 1g/cm^2</figcaption>
            </figure>
            <figure>
                <img src="Img/Part2_DefaultCloth2.png" alt="Part 2 Density: 15g/cm^2 (default)">
                <figcaption>Density: 15g/cm^2 (default)</figcaption>
            </figure>
            <figure>
                <img src="Img/Part2_Density30Cloth2.png" alt="Part 2 Density: 30g/cm^2">
                <figcaption>Density: 30g/cm^2</figcaption>
            </figure>
        </div>
        <p>Damping simulates loss of energy due to friction, heat loss, etc. Low damping results in the cloth swaying back and forth before hanging still. Higher percentages of damping result in the cloth falling slowly with no back and forth swaying. Here
            are some examples with damping=0.1%, 0.2%, and 0.5%.</p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part2_Damping0.1Cloth2.gif" alt="Part 2 Damping: 0.1%">
                <figcaption>Damping: 0.1%</figcaption>
            </figure>
            <figure>
                <img src="Img/Part2_DefaultCloth2.png" alt="Part 2 Damping: 0.2% (default)">
                <figcaption>Damping: 0.2% (default)</figcaption>
            </figure>
            <figure>
                <img src="Img/Part2_Damping05Cloth2.gif" alt="Part 2 Damping: 0.5%">
                <figcaption>Damping: 0.5%</figcaption>
            </figure>
        </div>
        <p>Here is an example of a rendered cloth pinned at the four corners:</p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part2_Cloth4.png" alt="Part 2 Cloth Pinned at 4 Corners">
                <figcaption>Cloth Pinned at 4 Corners</figcaption>
            </figure>
        </div>
        <h2>Part 3: Handling Collisions with Other Objects</h2>
        <p>To implement collisions of the cloth with other surfaces, we first check if a point mass has intersected with or is within the surface of an object (in our case, it is either a sphere or plane). If the cloth has intersected with (or is within) the surface of the object, we create a correction vector on the point mass’s last position to set (or "bump") the current position right above the surface.
        </p>
        <p>Here are images of our cloth draped over a sphere with different spring constants, ks = 500, 5000, and 50,000. The smaller the spring constant, the more folds there are on the cloth, and the larger the spring constant, the less folds there are on the cloth.
        </p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part3_sphere_ks_500.png" alt="Part 3 ks: 500N/m">
                <figcaption>ks: 500N/m</figcaption>
            </figure>
            <figure>
                <img src="Img/Part3_sphere_ks_5000.png" alt="Part 3 ks: 5000N/m (default)">
                <figcaption>ks: 5000N/m (default)</figcaption>
            </figure>
            <figure>
                <img src="Img/Part3_sphere_ks_50000.png" alt="Part 3 ks: 50000N/m">
                <figcaption>ks: 50000N/m</figcaption>
            </figure>
        </div>
        <p>Here is our cloth colliding with a flat plane:</p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part3_cloth_at_top_view_of_plane.png" alt="Part 3 Top View">
                <figcaption>Top View of Cloth on Plane</figcaption>
            </figure>
            <figure>
                <img src="Img/Part3_cloth_at_bottom_view_of_plane.png" alt="Part 3 Bottom View">
                <figcaption>Bottom View</figcaption>
            </figure>
        </div>
        <h2>Part 4: Handling Self-Collisions</h2>
        <p>To deal with self-collisions, we partitioned point masses into 3D box volumes, and hashed each point mass's location to uniquely map it to a float that represents its specific 3D box volume. This is called spatial hashing, and it speeds up the behavior of self-collisions in run time. With this implementation, instead of having to check if each point mass collides with every other point mass, we just have to check with the point masses who
            are also in its 3D hash box. We determine whether 2 point masses have collided if they are closer than a certain distance apart (i.e. if they are within 2 * thickness distance apart). If so, we adjust the colliding point masses  with correction vectors.
            </p>
        <p>Here are screenshots of a cloth collapsing on itself:</p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part4_beginning.png" alt="Part 4 Initial Collision">
                <figcaption>Initial Collision</figcaption>
            </figure>
            <figure>
                <img src="Img/Part4_middle.png" alt="Part 4 Middle of Collision">
                <figcaption>Middle of Collision</figcaption>
            </figure>
            <figure>
                <img src="Img/Part4_end.png" alt="Part 4 Final Resting State">
                <figcaption>Final Resting State</figcaption>
            </figure>
        </div>
        <p>Here are examples of the cloth folding over itself with varying densities: density = 1, 15, and 30, g/cm^2. At lower densities, the cloth falls like it’s lighter and folds with bigger folds. At higher densities, it looks heavy and creases deeply.
        </p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part4_density1.gif" alt="Part 4 Density: 1g/cm^2">
                <figcaption>Density: 1g/cm^2</figcaption>
            </figure>
            <figure>
                <img src="Img/Part4_default.gif" alt="Part 4 Density: 15g/cm^2 (default)">
                <figcaption>Density: 15g/cm^2 (default)</figcaption>
            </figure>
            <figure>
                <img src="Img/Part4_density30.gif" alt="Part 4 Density: 30g/cm^2">
                <figcaption>Density: 30g/cm^2</figcaption>
            </figure>
        </div>
        <p>Adjusting the spring constant, we see the opposite happen. At lower spring constants, the cloth is less “springy” and looks heavier. At higher spring constants, the fabric looks stiffer and bouncier, falling similar to the low-density simulations.</p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part4_fs500.gif" alt="Part 4 ks: 500N/m">
                <figcaption>ks: 500N/m</figcaption>
            </figure>
            <figure>
                <img src="Img/Part4_default.gif" alt="Part 4 ks: 5000N/m (default)">
                <figcaption>ks: 5000N/m (default)</figcaption>
            </figure>
            <figure>
                <img src="Img/Part4_fs50000.gif" alt="Part 4 ks: 50000N/m">
                <figcaption>ks: 50000N/m</figcaption>
            </figure>
        </div>
        <h2>Part 5: Shaders</h2>
        <p>In part 5, we wrote shader programs to render realistic surfaces like those we implemented with ray tracing. A Shader program is an isolated program that runs in parallel on GPU that executes sections of the graphics pipeline. It allows for a
            much faster application of rendering frames for real-time and interactive applications (as opposed to ray tracing). The vertex shader applies transforms to vertices and modifies their geometric properties like position and normal vectors,
            while the fragment shader take in the geometric attributes (calculated by the vertex shaders) and computes the final color that will be shown on the frame buffer. Note, that the vertex shader’s output is the fragment shader’s input.
        </p>
        <p>The Blinn-Phong shading model is a local shading model that is based on perceptual observations and combines the ambient lighting, diffusion lighting, and specular lighting of an object. This shading model is fast, simple, and makes objects look
            more realistic. Here are different examples of Blinn-Phong shading:
        </p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part_5_ambient_lighting.png" alt="Part 5 Only Ambient Component">
                <figcaption>Only Ambient</figcaption>
            </figure>
            <figure>
                <img src="Img/Part_5_diffusion_component.png" alt="Part 5 Only Diffusion Component">
                <figcaption>Only Diffusion</figcaption>
            </figure>
            <figure>
                <img src="Img/Part_5_specular_component.png" alt="Part 5 Only Specular Component">
                <figcaption>Only Specular</figcaption>
            </figure>
            <figure>
                <img src="Img/Part_5_all_components.png" alt="Part 5 All Components">
                <figcaption>All Components</figcaption>
            </figure>
        </div>
        <p>Here is an example of texture mapping with a picture of Greece:</p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part5_custom_texture_of_greece_1.png" alt="Part 5 Cloth and Sphere Texture Mapping">
                <figcaption>Cloth and Sphere</figcaption>
            </figure>
            <figure>
                <img src="Img/Part5_custom_texture_of_greece_2.png" alt="Part 5 Cloth over Sphere Texture Mapping">
                <figcaption>Cloth over Sphere</figcaption>
            </figure>
        </div>
        <p>We also implemented bump mapping. Bump mapping changes the surface of the object (the sphere and cloth) to have a texture that looks bumpy by changing the normal vectors of the object. The displacement mapping changes not only the surface (like
            bump), but also the shape of the object to look more jaggy. This is done by modifying the position of the vertices (in addition to modifying the normal vectors).
        </p>
        <p>Changing the sphere mesh’s coarseness does not seem to effect the bump shader. However, there is a noticeable difference in the displacement shader. As the sphere mesh’s coarseness increases, the more pronounced the texture (i.e. the dips and
            bumps) looks on the sphere. The sphere’s surface looks more jagged.
        </p>
        <p>Here are some examples of bumping mapping and displacement mapping:
        </p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part5_bump_mapping_on_cloth_o_16_a_16.png" alt="Part 5 Bump Mapping Cloth on Sphere, Normal: 16, Height: 16">
                <figcaption>Bump Mapping Cloth on Sphere</figcaption>
                <figcaption>Normal: 16, Height: 16</figcaption>

            </figure>
            <figure>
                <img src="Img/Part5_bump_mapping_on_sphere_o_16_a_16.png" alt="Part 5 Bump Mapping Sphere, Normal: 16, Height: 16">
                <figcaption>Bump Mapping Sphere</figcaption>
                <figcaption>Normal: 16, Height: 16</figcaption>
            </figure>
        </div>
        <div class="img-grid">
            <figure>
                <img src="Img/Part5_bump_mapping_on_cloth_o_128_a_128.png" alt="Part 5 Bump Mapping Cloth on Sphere, Normal: 128, Height: 128">
                <figcaption>Bump Mapping Cloth on Sphere</figcaption>
                <figcaption>Normal: 128, Height: 128</figcaption>
            </figure>
            <figure>
                <img src="Img/Part5_bump_mapping_on_sphere_o_128_a_128.png" alt="Part 5 Bump Mapping on Sphere, Normal: 128, Height: 128">
                <figcaption>Bump Mapping Sphere</figcaption>
                <figcaption>Normal: 128, Height: 128</figcaption>
            </figure>
        </div>
        <div class="img-grid">
            <figure>
                <img src="Img/Part5_displacement_mapphing_on_sphere_o_16_a_16.png" alt="Part 5 Displacement Mapping, Normal: 128, Height: 128">
                <figcaption>Displacement Mapping Sphere</figcaption>
                <figcaption>Normal: 16, Height: 16</figcaption>
            </figure>
            <figure>
                <img src="Img/Part5_displacement_mapphing_on_sphere_o_128_a_128.png" alt="Part 5 Displacement Mapping, Normal: 128, Height: 128">
                <figcaption>Displacement Mapping Sphere</figcaption>
                <figcaption>Normal: 128, Height: 128</figcaption>
            </figure>
        </div>
        <p>We also implemented mirror shading:
        </p>
        <div class="img-grid">
            <figure>
                <img src="Img/Part5_mirror_on_cloth.png" alt="Part 5 Mirror Shading Cloth On Sphere">
                <figcaption>Mirror Shading Cloth On Sphere</figcaption>
            </figure>
            <figure>
                <img src="Img/Part5_mirror_on_sphere.png" alt="Part 5 Mirror Shading Sphere">
                <figcaption>Mirror Shading Sphere</figcaption>
            </figure>
        </div>

        <h2>Web Page Link</h2>
        <p>
            https://cal-cs184-student.github.io/sp22-project-webpages-lucylanlou/proj4/index.html
        </p>
    </div>
</body>

</html>
